//EPISODE 6 CODE EXAMPLES (https://youtu.be/ZAoo-R8obog)

/*I. Arrays*/

//An array is a data structure into which data is collected and stored. Each entry is identifiable and accessible
//by an index number. Arrays in SuperCollider are "zero-indexed," meaning that the first index number is 0,
//not 1 (as is found in languages like MatLab).

//The following is an example of an array of integers:

[5, 7, 3]; //5 is in index 0, 7 in index 1, and 3 in index 2

//The basic way of initializing an array is by using the .new class method, declaring its maximum index number,
//and setting it to a variable:

a = Array.new(2);

//Content can be added to an array via the .add instance method:
a.add(5);

//.at posts what is stored in a particular index to the Post Window:
a.at(0);

//.addAll allows for the addition of multiple indices at once:
a.addAll([7, 3]); //(Make sure to enclose the content within square brackets)

//.at can check multiple indices at once as well:
a.at([1, 2]);

//SuperCollider does allow for the addition of at least one index past the stated maximum:
a.add(4);

//However, after this point, a new collection is returned as the fifth index includes only what was most
//recently added:
a.add(1);
a.add(8);

a.at(4); //This confirms the array with five indices is not actually stored in 'a' but is a new array altogether.

//This issue becomes moot so long as one gets into the habit of always setting the result of an .add instruction
//back to the variable containing the array:
a = a.add(33);
a.at(4); //Now includes the fifth index!

//Replacing content in indices can be achieved via the .put instance method. Unlike .add, .put does not have the
//capability to return a new array should the desired slot not be available, so there is no need to set the
//result back to the variable containing the array:
a.put(0, 8); //Places the integer '8' into index 0.
a.put(5, 1); //Results in an "Index out of range" error, as index 5 does not yet exist.

//If one wishes to initialize an array and expects to place content into its indices non-sequentially, the
//.newClear method is what one should use:
a = Array.newClear(5); //Sets up an array prefilled with 5 'nil' values: [nil, nil, nil, nil, nil]
a.put(2, 9); //We can now place the number '9' straight into index 2 without having to fill the first two indices.

//A syntactical alternative to .put is to set an index of an array directly to some value. This is achieved
//by enclosing the desired index number between brackets and using the equals sign:
a[4] = 20; //Achieves the same result as a.put(4, 20);

//Likewise, a syntactical shortcut to .at is to simply evaluate the above without setting it to anything:
a[4]; //Identical to a.at(4);

//The .new instance method is almost always understood by the interpreter and is therefore optional to specify:
a = Array(10); //Same as a = Array.new(10);

//This sets up a new array prefilled with the first ten values found in the Fibonacci Sequence:
a = Array.fib(10);

//One can skip the initialization process entirely and simply declare an array prefilled with one's intended
//values:
a = [5, 7, 3];

//One can also set up an empty array via the following:
a = [];

/*II. Arrays in Multichannel Expansion*/

//First, boot the server via Server > Boot Server.

//The following is a function that will take a note and output a major third based on that note, with a fadeTime
//of 3 seconds:
(
~chord = { |note=60, width=0.5, amp=0.2|
	VarSaw.ar([midicps(note), midicps(note+4)], 0, width, amp);
}.play(fadeTime: 3);
)

~chord.release;

//However, it doesn't quite behave as one might expect, as after releasing it, invoking the function with a new
//MIDI note value results in an error:
~chord.play(args: [\note, 65]); //This does NOT work!!

//Since { }.play is a convenience function, after compilation the variable, in this case ~chord, will now be
//set to the Synth that was generated by the function, not the function itself. As part of what { }.play does
//is to compile the SynthDef that provides the server with the byte code instructing it how the sound itself
//will be generated, we want to refer to *that* instead. We can achieve this conveniently through
//another convenience function: .asSynthDef, followed by .add so that the SynthDef is actually sent to and
//added to the server's registry of SynthDefs. (.asDefName is typically even better to use since it adds
//the def to the server automatically, but oddly that method does not allow for the use of fadeTime!)

//We don't bother setting the function to a variable, as the symbolic name is how we'll be referring to the
//Synth. (If we had decided to use .asDefName instead, then the variable name would act as the Synth name.)

(
{ |note=60, width=0.5, amp=0.2|
	VarSaw.ar([midicps(note), midicps(note+4)], 0, width, amp);
}.asSynthDef(fadeTime: 3, name: \chord).add;
)

//Now let's instance our Synth with its default values, assigning the variable to that so we can release it:
~chord = Synth(\chord);
~chord.release;

//We can now use the function as we were intending to all along:
~chord = Synth(\chord, [\note, 65]); //This sets the note argument to MIDI note value 65
~chord.release;

/***BONUS (not in video)***/
//If one wanted to eschew the convenience function altogether, one could write out the SynthDef as follows:
(
SynthDef.new(\chord, { |out=0, note=60, width=0.5, amp=0.2, gate=1| //We need to include both out and gate args.
	var sig = VarSaw.ar([midicps(note), midicps(note+4)], 0, width, amp);
	var env = EnvGate(0, gate, 3); //We have to manually construct an envelope for our fadeTime.

	Out.ar(out, sig * env); //Nothing will be bussed out without an Out UGen at the audio rate.
}).add;
)

~chord = Synth(\chord, [\note, 65]);
~chord.release;

//Manually constructing SynthDefs involves concepts not yet introduced in this tutorial series, and often
//doesn't offer tangible advantages over using the convenience functions (especially for relatively simple
//Synth definitions) so we'll be sticking with .asSynthDef and .asDefName for now.
/***END OF BONUS CONTENT***/

//If we wanted to expand the capabilities of our function so that it outputs a major triad instead of a major
//third, we can't simply add the fifth in our VarSaw's array:
(
{ |note=60, width=0.5, amp=0.2|
	VarSaw.ar([midicps(note), midicps(note+4), midicps(note+7)], 0, width, amp);
}.asSynthDef(fadeTime: 3, name: \chord).add;
)

~chord = Synth(\chord, [\note, 67, \width, 0.4]); //The fifth isn't being included in our stereo signal!
~chord.release;

//Arrays by default expand over multiple channels of audio, so what's in index 0 will be bussed to output
//channel 0, index 1 will go to output channel 1, index 2 is routed to output channel 2, and so on. In a
//typical stereo listening setup, output channel 2 is not routed to any outputs, and thus any signal piped
//through it will remain unheard. In order to combine each member of the chord, we'll need to use the Mix
//class to mix them together, followed by .dup so we get activity over both stereo channels:
(
{ |note=60, width=0.5, amp=0.2|
	Mix(VarSaw.ar([midicps(note), midicps(note+4), midicps(note+7)], 0, width, amp)).dup;
}.asSynthDef(fadeTime: 3, name: \chord).add;
)

~chord = Synth(\chord, [\note, 67, \width, 0.4]);
~chord.release;

//Mix has vestigial .ar and .kr class methods. They're no longer necessary as SC3 introduces .new (which
//automatically detects audio and control rates), though they remain in for backwards compatibility with SC2.
//Some people prefer still specifying .ar or .kr, as it provides further clarification at a glance as to
//the nature of the data being mixed. Just like specifying .new or using 'arg' tags over vertical pipes,
//it's all up to the preference of the programmer:
(
{ |note=60, width=0.5, amp=0.2|
	Mix.ar(VarSaw.ar([midicps(note), midicps(note+4), midicps(note+7)], 0, width, amp)).dup;
}.asSynthDef(fadeTime: 3, name: \chord).add;
)

~chord = Synth(\chord, [\note, 67, \width, 0.4]);
~chord.release;